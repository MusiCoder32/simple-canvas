<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Leason 7 - 综合案例（相机/缩放/命中/动画/导出）</title>
  <style>
    :root { color-scheme: light dark; }
    body { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; margin: 24px; }
    canvas { width: 920px; max-width: 100%; height: 520px; border: 1px solid color-mix(in srgb, CanvasText 20%, transparent); border-radius: 12px; background: color-mix(in srgb, Canvas 92%, CanvasText 8%); display: block; }
    .bar { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; margin: 12px 0 12px; }
    button { padding: 8px 12px; border-radius: 10px; border: 1px solid color-mix(in srgb, CanvasText 18%, transparent); background: color-mix(in srgb, Canvas 95%, CanvasText 5%); color: CanvasText; cursor: pointer; }
    .hint { max-width: 920px; line-height: 1.7; opacity: 0.95; }
    code { background: color-mix(in srgb, CanvasText 12%, transparent); padding: 2px 6px; border-radius: 6px; }
  </style>
</head>
<body>
  <h1>Leason 7：综合案例（相机变换 + 命中测试 + 动画 + 导出）</h1>
  <p class="hint">
    这是一个“迷你场景编辑器/小游戏底座”：
    <br />- 拖拽对象：左键按住圆点拖动
    <br />- 平移相机：按住空格 + 左键拖动（或在空白处直接拖动）
    <br />- 缩放：滚轮缩放（以鼠标点为中心）
    <br />- 动画：对象会自己运动（fixed timestep），你可以暂停/继续
    <br />- 导出：将当前画面导出 PNG（注意 tainted canvas 规则）
  </p>

  <div class="bar">
    <button id="btn-toggle">暂停</button>
    <button id="btn-reset">重置</button>
    <button id="btn-export">导出 PNG</button>
    <span id="stat" style="font-size:14px; opacity:0.95;"></span>
  </div>

  <canvas id="c"></canvas>

  <script>
    const canvas = document.querySelector('#c');
    const ctx = canvas.getContext('2d');

    const btnToggle = document.querySelector('#btn-toggle');
    const btnReset = document.querySelector('#btn-reset');
    const btnExport = document.querySelector('#btn-export');
    const statEl = document.querySelector('#stat');

    const CSS_W = 920;
    const CSS_H = 520;

    function getDpr() {
      return Math.max(1, window.devicePixelRatio || 1);
    }

    function setupHiDPICanvas() {
      const dpr = getDpr();
      canvas.style.width = CSS_W + 'px';
      canvas.style.height = CSS_H + 'px';
      canvas.width = Math.round(CSS_W * dpr);
      canvas.height = Math.round(CSS_H * dpr);

      // 先把单位规范为“CSS 像素”
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      return dpr;
    }

    function getCanvasPoint(e) {
      const rect = canvas.getBoundingClientRect();
      return { x: e.clientX - rect.left, y: e.clientY - rect.top };
    }

    // --- 相机（把“屏幕坐标”映射到“世界坐标”）---
    // 你可以把它理解成：我们在画之前先做 transform，相当于移动/缩放观察窗口。
    const camera = {
      x: 0,
      y: 0,
      zoom: 1.0
    };

    function screenToWorld(p) {
      // 屏幕（canvas 内 CSS 像素）-> 世界坐标
      return {
        x: (p.x - CSS_W / 2) / camera.zoom + camera.x,
        y: (p.y - CSS_H / 2) / camera.zoom + camera.y,
      };
    }

    function applyCameraTransform() {
      // 绘制世界前设置：
      // 1) 平移到屏幕中心
      // 2) 缩放
      // 3) 平移相机位置（把相机视为“世界向相反方向移动”）
      ctx.translate(CSS_W / 2, CSS_H / 2);
      ctx.scale(camera.zoom, camera.zoom);
      ctx.translate(-camera.x, -camera.y);
    }

    // --- 离屏缓存：网格 tile（pattern）---
    // 网格不需要每帧用很多 lineTo 画，做成一个小 tile 后 pattern 填充即可。
    function createGridPattern() {
      const size = 160;
      const off = (typeof OffscreenCanvas !== 'undefined')
        ? new OffscreenCanvas(size, size)
        : Object.assign(document.createElement('canvas'), { width: size, height: size });

      const octx = off.getContext('2d');
      octx.clearRect(0, 0, size, size);

      // 背景透明，只画线
      octx.strokeStyle = 'rgba(255,255,255,0.10)';
      octx.lineWidth = 1;

      // 小格
      for (let x = 0; x <= size; x += 20) {
        octx.beginPath();
        octx.moveTo(x + 0.5, 0);
        octx.lineTo(x + 0.5, size);
        octx.stroke();
      }
      for (let y = 0; y <= size; y += 20) {
        octx.beginPath();
        octx.moveTo(0, y + 0.5);
        octx.lineTo(size, y + 0.5);
        octx.stroke();
      }

      // 大格（更醒目）
      octx.strokeStyle = 'rgba(255,255,255,0.18)';
      octx.lineWidth = 1.5;
      octx.beginPath();
      octx.rect(0.5, 0.5, size - 1, size - 1);
      octx.stroke();

      return ctx.createPattern(off, 'repeat');
    }

    const gridPattern = createGridPattern();

    // --- 场景对象 ---
    const world = {
      minX: -700,
      maxX: 700,
      minY: -420,
      maxY: 420,
      gravity: 0
    };

    function rand(min, max) { return min + Math.random() * (max - min); }

    let objects = [];

    function resetScene() {
      camera.x = 0;
      camera.y = 0;
      camera.zoom = 1.0;

      objects = [];
      for (let i = 0; i < 14; i++) {
        objects.push({
          id: 'o' + i,
          x: rand(world.minX * 0.7, world.maxX * 0.7),
          y: rand(world.minY * 0.7, world.maxY * 0.7),
          r: rand(16, 34),
          vx: rand(-120, 120),
          vy: rand(-90, 90),
          hue: Math.floor(rand(180, 340))
        });
      }

      selected = null;
    }

    // --- 命中测试（世界坐标）---
    function hitTestWorld(pw) {
      // 从上到下（后画的在上）
      for (let i = objects.length - 1; i >= 0; i--) {
        const o = objects[i];
        const dx = pw.x - o.x;
        const dy = pw.y - o.y;
        if (dx * dx + dy * dy <= o.r * o.r) {
          return o;
        }
      }
      return null;
    }

    // --- 动画：fixed timestep ---
    let running = true;
    let lastTs = performance.now();
    let accumulator = 0;
    const fixedDt = 1 / 120;
    const maxFrameDt = 0.05;

    function stepPhysics(dt) {
      for (const o of objects) {
        o.x += o.vx * dt;
        o.y += o.vy * dt;

        // 边界反弹
        if (o.x - o.r < world.minX) { o.x = world.minX + o.r; o.vx = Math.abs(o.vx); }
        if (o.x + o.r > world.maxX) { o.x = world.maxX - o.r; o.vx = -Math.abs(o.vx); }
        if (o.y - o.r < world.minY) { o.y = world.minY + o.r; o.vy = Math.abs(o.vy); }
        if (o.y + o.r > world.maxY) { o.y = world.maxY - o.r; o.vy = -Math.abs(o.vy); }

        // 一点点阻尼，让画面更稳
        o.vx *= 0.999;
        o.vy *= 0.999;
      }
    }

    // --- 渲染 ---
    function drawWorldBounds() {
      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,0.35)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.rect(world.minX, world.minY, world.maxX - world.minX, world.maxY - world.minY);
      ctx.stroke();
      ctx.restore();
    }

    function render() {
      // 先在“屏幕坐标系”里清屏/画 HUD 背景
      ctx.setTransform(getDpr(), 0, 0, getDpr(), 0, 0); // 确保是 CSS 坐标单位
      ctx.clearRect(0, 0, CSS_W, CSS_H);

      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.12)';
      ctx.fillRect(0, 0, CSS_W, CSS_H);
      ctx.restore();

      // 然后进入“世界坐标系”：应用相机
      ctx.save();
      applyCameraTransform();

      // 网格 pattern：pattern 会受 transform 影响（跟随相机缩放/平移）
      ctx.save();
      ctx.fillStyle = gridPattern;
      ctx.fillRect(world.minX - 2000, world.minY - 2000, 4000, 4000);
      ctx.restore();

      drawWorldBounds();

      // 画对象
      for (const o of objects) {
        ctx.save();

        // 主体
        ctx.fillStyle = `hsla(${o.hue}, 92%, 62%, 0.85)`;
        ctx.beginPath();
        ctx.arc(o.x, o.y, o.r, 0, Math.PI * 2);
        ctx.fill();

        // 高光
        ctx.globalAlpha = 0.22;
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(o.x - o.r * 0.25, o.y - o.r * 0.25, o.r * 0.35, 0, Math.PI * 2);
        ctx.fill();

        // 选中描边
        if (selected === o) {
          ctx.globalAlpha = 1;
          ctx.lineWidth = 4 / camera.zoom; // 注意：在世界坐标里，为了“视觉恒定”的描边宽度，要除以 zoom
          ctx.strokeStyle = 'rgba(255,255,255,0.95)';
          ctx.setLineDash([10 / camera.zoom, 6 / camera.zoom]);
          ctx.beginPath();
          ctx.arc(o.x, o.y, o.r + 2 / camera.zoom, 0, Math.PI * 2);
          ctx.stroke();
        }

        ctx.restore();
      }

      ctx.restore(); // 退出世界坐标系

      // HUD 文本（屏幕坐标）
      ctx.save();
      ctx.font = '14px ui-sans-serif, system-ui';
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.fillText(`camera: (${camera.x.toFixed(1)}, ${camera.y.toFixed(1)}) zoom=${camera.zoom.toFixed(2)}`, 16, 22);
      ctx.fillText(`selected: ${selected ? selected.id : '(none)'}`, 16, 44);
      ctx.restore();
    }

    // --- 交互：选择/拖拽/平移/缩放 ---
    let selected = null;
    let draggingMode = null; // 'object' | 'pan'
    let dragStart = null;

    // 空格键按住：强制进入平移模式
    let spaceDown = false;
    window.addEventListener('keydown', (e) => { if (e.code === 'Space') spaceDown = true; });
    window.addEventListener('keyup', (e) => { if (e.code === 'Space') spaceDown = false; });

    canvas.addEventListener('mousedown', (e) => {
      const ps = getCanvasPoint(e);
      const pw = screenToWorld(ps);

      const hit = hitTestWorld(pw);

      if (!spaceDown && hit) {
        selected = hit;
        draggingMode = 'object';
        dragStart = {
          mouseWorldX: pw.x,
          mouseWorldY: pw.y,
          objX: hit.x,
          objY: hit.y
        };

        // 置顶
        const idx = objects.indexOf(hit);
        if (idx >= 0) {
          objects.splice(idx, 1);
          objects.push(hit);
        }
      } else {
        // 平移相机
        draggingMode = 'pan';
        dragStart = {
          mouseScreenX: ps.x,
          mouseScreenY: ps.y,
          camX: camera.x,
          camY: camera.y
        };
      }

      render();
    });

    canvas.addEventListener('mousemove', (e) => {
      if (!draggingMode) return;

      const ps = getCanvasPoint(e);
      const pw = screenToWorld(ps);

      if (draggingMode === 'object' && selected && dragStart) {
        // 保持鼠标与对象的相对位置（世界坐标）
        selected.x = dragStart.objX + (pw.x - dragStart.mouseWorldX);
        selected.y = dragStart.objY + (pw.y - dragStart.mouseWorldY);
        render();
      }

      if (draggingMode === 'pan' && dragStart) {
        // 平移：屏幕移动 dx 对应世界移动 dx/zoom
        const dx = (ps.x - dragStart.mouseScreenX) / camera.zoom;
        const dy = (ps.y - dragStart.mouseScreenY) / camera.zoom;
        camera.x = dragStart.camX - dx;
        camera.y = dragStart.camY - dy;
        render();
      }
    });

    window.addEventListener('mouseup', () => {
      draggingMode = null;
      dragStart = null;
    });

    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();

      const ps = getCanvasPoint(e);
      const before = screenToWorld(ps);

      // 缩放倍率：滚轮向上放大、向下缩小
      // deltaY 单位不固定（不同设备不同），一般只取符号和一个温和系数。
      const scale = Math.exp(-e.deltaY * 0.0015);
      const nextZoom = Math.min(4.0, Math.max(0.25, camera.zoom * scale));
      camera.zoom = nextZoom;

      const after = screenToWorld(ps);

      // 让鼠标指向的世界点保持不动：调整相机中心
      camera.x += (before.x - after.x);
      camera.y += (before.y - after.y);

      render();
    }, { passive: false });

    // --- 导出 ---
    btnExport.addEventListener('click', () => {
      try {
        // 如果画布被跨域资源污染（tainted），这里会抛异常。
        const url = canvas.toDataURL('image/png');
        // 用新窗口打开导出的图片
        window.open(url, '_blank');
      } catch (err) {
        alert('导出失败：' + err + '\n\n如果你绘制过无 CORS 授权的跨域图片，画布会 tainted，无法导出。');
      }
    });

    // --- 控制：暂停/重置 ---
    btnToggle.addEventListener('click', () => {
      running = !running;
      btnToggle.textContent = running ? '暂停' : '继续';
      if (running) {
        lastTs = performance.now();
        requestAnimationFrame(tick);
      }
    });

    btnReset.addEventListener('click', () => {
      resetScene();
      render();
    });

    // --- 主循环 ---
    const fps = { lastUpdate: performance.now(), frames: 0, value: 0 };

    function tick(nowTs) {
      if (!running) return;

      let frameDt = (nowTs - lastTs) / 1000;
      lastTs = nowTs;
      frameDt = Math.min(frameDt, maxFrameDt);

      accumulator += frameDt;
      while (accumulator >= fixedDt) {
        // 拖拽时也继续跑物理会有点别扭：这里如果正在拖拽对象，可以选择暂停物理。
        // 为了教学简单：拖拽对象时仍然更新其它对象，选中对象也会被你拖拽“覆盖”。
        stepPhysics(fixedDt);
        accumulator -= fixedDt;
      }

      render();

      fps.frames++;
      const elapsed = nowTs - fps.lastUpdate;
      if (elapsed >= 500) {
        fps.value = (fps.frames / elapsed) * 1000;
        fps.frames = 0;
        fps.lastUpdate = nowTs;
      }

      statEl.textContent = `FPS ~ ${fps.value.toFixed(0)} | objects=${objects.length}`;

      requestAnimationFrame(tick);
    }

    // --- 启动 ---
    setupHiDPICanvas();
    resetScene();
    render();
    requestAnimationFrame(tick);

    window.addEventListener('resize', () => {
      setupHiDPICanvas();
      render();
    });
  </script>
</body>
</html>
